'use strict';

var fs = require('fs');
var path = require('path');
var zlib = require('zlib');
var util = require('util');
var Emitter = require('events').EventEmitter;

var pipe = require('pipe-io');
var through = require('through2');

util.inherits(Gzip, Emitter);

module.exports = function (from, to) {
    var emitter = new Gzip(from, to);

    process.nextTick(function () {
        emitter._start();
    });

    return emitter;
};

function Gzip(from, to) {
    var name = path.basename(from.replace(/\.gz/, ''));

    this._from = from;
    this._to = path.join(to, name);
    this._i = 0;
    this._n = 0;
    this._percent = 0;
    this._percentPrev = 0;
}

Gzip.prototype._start = function () {
    var _this = this;

    var from = this._from;
    var to = this._to;

    fs.stat(from, function (e, stat) {
        if (e) return _this.emit('error', e);

        if (!stat.size) return _this.emit('error', Error('archive is empty'));

        _this._n = stat.size;

        var unzipStream = zlib.createGunzip();
        var readStream = fs.createReadStream(from);
        var writeStream = fs.createWriteStream(to);
        var progressStream = _this.getProgressStream();

        pipe([readStream, progressStream, unzipStream, writeStream], function (e) {
            if (e) return _this.emit('error', e);

            _this.emit('file', path.basename(to));
            _this.emit('end');
        });
    });
};

Gzip.prototype.getProgressStream = function () {
    var _this2 = this;

    return through(function (chunk, enc, callback) {
        _this2._i += chunk.length;
        _this2._progress();
        callback(null, chunk);
    });
};

Gzip.prototype._progress = function () {
    var value = Math.round(this._i * 100 / this._n);

    this._percent = value;

    if (value !== this._percentPrev) {
        this._percentPrev = value;
        this.emit('progress', value);
    }
};