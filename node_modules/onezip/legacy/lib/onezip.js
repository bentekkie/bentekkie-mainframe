'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var fs = require('fs');
var path = require('path');
var util = require('util');
var Emitter = require('events').EventEmitter;

var findit = require('findit');
var assert = require('assert');
var pipe = require('pipe-io/legacy');

var mkdirp = require('mkdirp');
var yazl = require('yazl');
var yauzl = require('yauzl');
var async = require('async');
var eachSeries = async.eachSeries;

util.inherits(OneZip, Emitter);

module.exports = onezip;
module.exports.pack = onezip('pack');
module.exports.extract = onezip('extract');

function check(from, to, files) {
    assert(typeof from === 'string', 'from should be a string!');
    assert(/string|object/.test(typeof to === 'undefined' ? 'undefined' : _typeof(to)), 'to should be string or object!');

    if (arguments.length > 2) assert(Array.isArray(files), 'files should be an array!');
}

function checkOperation(operation) {
    if (!/^(pack|extract)$/.test(operation)) throw Error('operations could be "pack" or "extract" only!');
}

function onezip(operation) {
    checkOperation(operation);
    return function (from, to, files) {
        return new OneZip(operation, from, to, files);
    };
}

function OneZip(operation, from, to, files) {
    var _this = this;

    if (operation === 'extract') check(from, to);else check(from, to, files);

    process.nextTick(function () {
        Emitter.call(_this);
        _this._i = 0;
        _this._n = 0;

        _this._percent = 0;
        _this._percentPrev = 0;

        _this._names = [];

        switch (operation) {
            case 'pack':
                _this._from = endSlash(from);
                _this._to = to;

                if (!files.length) return _this.emit('error', Error('Nothing to pack!'));

                _this._parallel(from, files, function () {
                    if (_this._abort) return _this.emit('end');

                    _this._pack();
                });
                break;

            case 'extract':
                _this._from = from;
                _this._to = endSlash(to);
                _this._parse(function (error) {
                    if (!error) {
                        _this._extract(_this._from);
                    } else {
                        _this.emit('error', error);
                    }
                });
                break;
        }
    });
}

OneZip.prototype.abort = function () {
    this._abort = true;
};

OneZip.prototype._parallel = function (from, files, callback) {
    var _this2 = this;

    var i = files.length;

    var fn = function fn() {
        if (! --i) callback();
    };

    files.forEach(function (name) {
        var full = path.join(from, name);

        _this2._findFiles(full, fn);
    });
};

OneZip.prototype._findFiles = function (filename, fn) {
    var _this3 = this;

    var finder = findit(filename);
    var inc = function inc(name) {
        var filename = name.replace('' + _this3._from, '');
        _this3._names.push(filename);
        ++_this3._n;
    };

    finder.on('file', inc);
    finder.on('error', function (error) {
        _this3.emit('error', error);
        _this3.abort();
    });

    finder.on('directory', inc);
    finder.on('link', inc);
    finder.on('end', fn);
};

OneZip.prototype._pack = function () {
    var _this4 = this;

    this.emit('start');

    var from = this._from;
    var to = this._to;
    var zipfile = new yazl.ZipFile();

    eachSeries(this._names, function (name, fn) {
        var filename = path.join(from, name);

        fs.stat(filename, function (error, stat) {
            if (error) return fn(error);

            var end = function end(name) {
                _this4.emit('file', name);
                _this4._progress();
            };

            if (stat.isDirectory()) {
                zipfile.addEmptyDirectory(name);
                end(name);
            } else {
                var stream = _this4._createReadStream(filename, function () {
                    end(name);
                });

                zipfile.addReadStream(stream, name);
            }

            fn();
        });
    }, function (error) {
        if (error) return _this4.emit('error', error);

        zipfile.end();

        var streamFile = (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to : fs.createWriteStream(to);

        pipe([zipfile.outputStream, streamFile], function (error) {
            if (error) return _this4.emit('error', error);

            if (!_this4._abort) return _this4.emit('end');

            _this4._unlink(to);
        });
    });
};

OneZip.prototype._createReadStream = function (filename, end) {
    var _this5 = this;

    return fs.createReadStream(filename).on('error', function (error) {
        _this5.emit('error', error);
    }).on('end', function () {
        end();
    });
};

OneZip.prototype._onOpenReadStream = function (success) {
    var _this6 = this;

    return function (error, readStream) {
        if (error) return _this6.emit('error', error);

        success(readStream);
    };
};

OneZip.prototype._unlink = function (to) {
    var _this7 = this;

    fs.unlink(to, function (error) {
        if (error) return _this7.emit('error', error);

        _this7.emit('end');
    });
};

OneZip.prototype._parse = function (fn) {
    var _this8 = this;

    var from = this._from;

    yauzl.open(from, function (error, zipfile) {
        if (error) return fn(error);

        zipfile.on('entry', function () {
            ++_this8._n;
        });

        zipfile.once('end', function () {
            fn();
        });
    });
};

OneZip.prototype._extract = function (from) {
    var _this9 = this;

    this.emit('start');

    yauzl.open(from, { lazyEntries: true, autoClose: false }, function (error, zipfile) {
        var handleError = function handleError(error) {
            if (error) {
                _this9.emit('error', error);
            }
        };

        if (error) return handleError(error);

        zipfile.readEntry();
        zipfile.on('entry', function (entry) {
            var fileName = entry.fileName;
            var fn = function fn(error) {
                if (error) return handleError(error);

                _this9._progress();
                _this9.emit('file', fileName);
                zipfile.readEntry();
            };

            if (/\/$/.test(fileName)) mkdirp(fileName, fn);else zipfile.openReadStream(entry, _this9._onOpenReadStream(function (readStream) {
                _this9._writeFile(fileName, readStream, fn);
            }));
        });

        zipfile.once('end', function () {
            _this9.emit('end');
        });
    });
};

OneZip.prototype._writeFile = function (fileName, readStream, fn) {
    var _this10 = this;

    mkdirp(path.dirname(fileName), function (error) {
        if (error) return fn(error);

        var name = path.join(_this10._to, fileName);
        var writeStream = fs.createWriteStream(name);

        pipe([readStream, writeStream], fn);
    });
};

OneZip.prototype._progress = function () {
    ++this._i;

    var value = Math.round(this._i * 100 / this._n);

    this._percent = value;

    if (value !== this._percentPrev) {
        this._percentPrev = value;
        this.emit('progress', value);
    }
};

function endSlash(str) {
    var last = str.length - 1;

    if (str[last] === path.sep) return str;

    return str + path.sep;
}