'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var fs = require('fs');
var path = require('path');
var zlib = require('zlib');
var gunzip = require('gunzip-maybe');
var util = require('util');
var findit = require('findit');
var assert = require('assert');
var Emitter = require('events').EventEmitter;
var tar = require('tar-fs');
var tarStream = require('tar-stream');
var pipe = require('pipe-io/legacy');

util.inherits(Jaguar, Emitter);

module.exports = jaguar;
module.exports.pack = jaguar('pack');
module.exports.extract = jaguar('extract');

function check(from, to, files) {
    assert(typeof from === 'string', 'from should be a string!');
    assert(/string|object/.test(typeof to === 'undefined' ? 'undefined' : _typeof(to)), 'to should be string or object!');

    if (arguments.length > 2) assert(Array.isArray(files), 'files should be an array!');
}

function checkOperation(operation) {
    if (!/^(pack|extract)$/.test(operation)) throw Error('operations: pack or extract only!');
}

function jaguar(operation) {
    checkOperation(operation);

    return function (from, to, files) {
        return new Jaguar(operation, from, to, files);
    };
}

function Jaguar(operation, from, to, files) {
    var _this = this;

    if (operation === 'pack') check(from, to, files);else check(from, to);

    process.nextTick(function () {
        Emitter.call(_this);
        _this._i = 0;
        _this._n = 0;

        _this._percent = 0;
        _this._percentPrev = 0;

        _this._from = from;
        _this._to = to;

        switch (operation) {
            case 'pack':
                _this._names = files.slice();

                if (!files.length) return _this._emitError(Error('Nothing to pack!'));

                _this._parallel(from, files, function () {
                    if (_this._wasError) return;

                    if (_this._abort) return _this.emit('end');

                    _this._pack();
                });
                break;

            case 'extract':
                _this._parse(from, function (error) {
                    if (error) return _this._emitError(error);

                    if (!_this._n) return _this._emitError(Error('No entries found'));

                    return _this._extract();
                });
                break;
        }
    });
}

Jaguar.prototype.abort = function () {
    this._abort = true;
};

Jaguar.prototype._emitError = function (e) {
    this._wasError = true;
    this.emit('error', e);
};

Jaguar.prototype._parallel = function (from, files, callback) {
    var _this2 = this;

    var i = files.length;

    var fn = function fn() {
        if (! --i) callback();
    };

    files.forEach(function (name) {
        var full = path.join(from, name);

        _this2._findFiles(full, fn);
    });
};

Jaguar.prototype._findFiles = function (filename, fn) {
    var _this3 = this;

    var finder = findit(filename);

    var inc = function inc() {
        ++_this3._n;
    };

    finder.on('file', inc);
    finder.on('error', function (error) {
        _this3._emitError(error);
    });

    finder.on('directory', inc);
    finder.on('link', inc);
    finder.on('end', fn);
};

Jaguar.prototype._pack = function () {
    var _this4 = this;

    this.emit('start');

    var from = this._from;
    var to = this._to;

    var streamFile = (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to : fs.createWriteStream(to);

    var streamZip = zlib.createGzip();

    var streamTar = tar.pack(from, {
        entries: this._names,
        map: function map(header) {
            _this4._progress();
            _this4.emit('file', header.name);

            return header;
        }
    });

    pipe([streamTar, streamZip, streamFile], function (error) {
        if (error) return _this4._emitError(error);

        if (!_this4._abort) return _this4.emit('end');

        _this4._unlink(to);
    });
};

Jaguar.prototype._unlink = function (to) {
    var _this5 = this;

    fs.unlink(to, function (error) {
        if (error) return _this5._emitError(error);

        _this5.emit('end');
    });
};

Jaguar.prototype._extract = function () {
    var _this6 = this;

    this.emit('start');

    var from = this._from;
    var to = this._to;
    var streamFile = fs.createReadStream(from);
    var streamUnzip = gunzip();
    var streamUntar = tar.extract(to);

    streamUntar.on('entry', function (header) {
        _this6._progress();
        _this6.emit('file', header.name);
    });

    streamUntar.on('finish', function () {
        _this6.emit('end');
    });

    pipe([streamFile, streamUnzip, streamUntar], function (e) {
        e && _this6._emitError(e);
    });
};

Jaguar.prototype._parse = function (name, callback) {
    var _this7 = this;

    var streamFile = fs.createReadStream(name);
    var streamUnzip = gunzip();
    var streamParse = tarStream.extract();

    streamParse.on('entry', function (header, stream, callback) {
        stream.on('end', function () {
            ++_this7._n;

            callback();
        });

        stream.resume();
    });

    streamParse.on('finish', callback);

    pipe([streamFile, streamUnzip, streamParse], function (error) {
        error && callback(error);
    });
};

Jaguar.prototype._progress = function () {
    ++this._i;

    var value = Math.round(this._i * 100 / this._n);

    this._percent = value;

    if (value !== this._percentPrev) {
        this._percentPrev = value;
        this.emit('progress', value);
    }
};