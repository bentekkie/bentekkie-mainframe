'use strict';

var fs = require('fs');
var path = require('path');

var size = require('trammel');
var time = require('timem');
var check = require('checkup');
var copymitter = require('copymitter/legacy');
var remy = require('remy/legacy');
var mkdir = require('mkdirp');

var readify = require('readify/legacy');
var win = require('win32/legacy');

var flop = exports;

var isWin = process.platform === 'win32';

exports.create = function (path, callback) {
    check.type('path', path, 'string').type('callback', callback, 'function');

    mkdir(path, callback);
};

exports.read = function (path, type, options, callback) {
    if (!callback && !options) {
        callback = type;
        options = {};
    } else if (!callback) {
        callback = options;
        options = type;
    }

    check.type('path', path, 'string').type('callback', callback, 'function');

    switch (type) {
        case 'size':
            size(path, callback);
            break;

        case 'size raw':
            size(path, { type: 'raw' }, callback);
            break;

        case 'time':
            time(path, callback);
            break;

        case 'time raw':
            time(path, 'raw', callback);
            break;

        case 'raw':
            options.type = 'raw';
            readify(path, options, callback);
            break;

        default:
            if (isWin && path === '/') return getRoot(callback);

            readify(path, options, callback);
            break;
    }
};

exports.delete = function (path, files, callback) {
    if (!callback) {
        callback = files;
        files = null;
    }

    check.type('path', path, 'string').type('callback', callback, 'function');

    remy(path, files).on('error', callback).on('end', callback);
};

exports.move = function (from, to, callback) {
    check.type('from', from, 'string').type('to', to, 'string').type('callback', callback, 'function');

    fs.rename(from, to, function (error) {
        var regexp = /EXDEV|ENOTEMPTY/;

        if (!error || !regexp.test(error.code)) return callback(error);

        flop.copy(from, to, function (error) {
            if (error) return callback(error);

            flop.delete(from, callback);
        });
    });
};

exports.copy = function (from, to, callback) {
    check.type('from', from, 'string').type('to', to, 'string').type('callback', callback, 'function');

    var name = path.basename(from);
    var fromPart = from.replace(name, '');
    var toPart = to.replace(name, '');

    copymitter(fromPart, toPart, [name]).on('error', callback).on('end', callback);
};

function getRoot(callback) {
    win.getVolumes(function (error, volumes) {
        var data = {
            path: '/',
            files: []
        };

        if (!error) data.files = volumes.map(function (volume) {
            return {
                name: volume,
                size: 'dir',
                date: '--.--.----',
                mode: '--- --- ---',
                owner: 0
            };
        });

        callback(error, data);
    });
}